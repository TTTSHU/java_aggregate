List集合：
一（Arraylist）：
1、首先判断这个集合的初始值是不是为o
  如果为0的话那在存储数据的时候就会创建一个数组elementData
  然后通过minCapacity判断扩容到长度大小为10的数组
2、如果集合有初始值并要存储的数据位数在集合的初始值之内那么就会创建一个大小为集合初始值的elementData数组
3、如果这个集合的初始值不为0而且要存储的数据位数大于list的初始值的话那么
  就会通过elementData以及minCapacity来将它扩容到原来的1.5倍
二（vector）：
1、当你创建一个vector集合时会自动创建一个大小为10的数组
2、当你的要存储的数据位数通过minCapacity判断大于10的时候或者大于初始化的值时，
   那么它就会通过elementData数组将大小扩容到20或者初始值的两倍
Arraylist和vector异同点：
同：1、都是list的子类
   2、底层结构都是数组
   3、都比较适合查询
异：1、Arraylist线程不安全，vector的方法都有synchronized修饰：线程安全
   2、Arraylist查询快，vector查询慢
   3、Arraylist集合初始值为0，vector集合初始值为10
三（LinkedList）
1、通过一个Node类变成一个双向链表
Arraylist和LinkedList的比较：
LinkedList的底层是链表，增删快，查询慢；
Set接口：
1、set接口的实现类的对象的add()不能存放相同的元素/对象,可以存放一个null
2、set接口的实现类的对象的取出顺序和存放的顺序不一致，而且取出后的顺序不会改变(在集合不变的情况下)
一:(HashSet)
HashSet的底层原理：
1、先new一个HashSet然后底层就会newHashMap()=map
2、然后走一个add()方法调用map.put,然后通过一个hash(key)得到一个hash值
3、然后return到一个putVal()方法,如果table为空的话就会通过一个resize()方法创建16的数组
4、通过hash值计算出数组的索引,如果这索引指向的值为空的话那么就在下面创建一个newNode(hash, key, value, null)也就是节点
5、如果计算出来的索引不为空的话那么就会把新的key值的hash值与计算出索引的key的hash值比较，如果两个key的对象指向的地址一样
  或者通过.equals方法的值为turn那就不添加
6、如果索引不为空并且两个key的对象指向的地址不一样和通过.equals方法的值为假那么就通过for循环遍历添加
LinkedHashSet底层原理：
1、LinkedHashSet的底层是LinkedHashMap
2、基本原理和HashSet一致，但是当代码走到newNode()时会创建一个Entry类接受数据并来到linkNodeLast（）方法，
  来达成一个双向的目的
TreeSet(排序):
TreeSet类最重要的是可以new一个比较器Comparator的方法来进行排序
Map接口：
一：（HashMap）
1、HashMap的Key不能重复，如果重复的话那么就会把原先的key给覆盖掉
2、HashMao的遍历是通过调用.entrySet()来进行遍历
3、HashMap的k—-v是存放在HashMap&Node类（map接口的子类里：Node）
4、HashMap的底层是一个单向链表
5、HashMap&Node类实现了Map.Entry<K,V>接口所以就把对象放在entry里面然后掉Entry接口里面的getkey()和getvalue（）来获取K_v
HashMap的扩容机制：
1、当Node对象存在一个hashCold里并且存的对象的数量等于8时，
   如果table表小于64那么table就会进行一个二倍扩容，如果再存的话那就再次扩容，直到等于64时，就会变成红黑树存放
二：(HashTable)
1、HashTable的初始值是HashTable$Entry[11]的table
2、HashTable的key和value值都不能为空，如果为空则会报空指针异常
3、HashTable的扩容机制是*2+1；
4、HashTable有线程安全，比hashmap效率低
三：TreeMap
TreeMap类是能newComparator接口来进行排序

